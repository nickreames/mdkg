# mdkg pack
root: root:task-1
depth: 2
verbose: true
nodes: 17
truncated: max_nodes=false max_bytes=false
generated_at: 2026-01-14T03:11:37.019Z

included_nodes:
- root:task-1
- root:epic-1
- root:edd-1
- root:dec-1
- root:dec-2
- root:dec-3
- root:dec-4
- root:dec-5
- root:dec-6
- root:dec-7
- root:rule-1
- root:rule-2
- root:rule-3
- root:rule-4
- root:rule-5
- root:rule-6
- root:rule-guide

---

## root:task-1
qid: root:task-1
type: task
title: claim npm name and bootstrap publish safety
status: done
priority: 0
path: .mdkg/work/task-1-claim-npm-name-and-bootstrap-publish-safety.md
links: npm:mdkg
artifacts: publish-whitelist, tarball-verified, bin-wired


# Overview

Ensure the npm package name `mdkg` is claimed and publishing is configured so only safe artifacts are shipped (no `.mdkg/` content).

# Acceptance Criteria

- npm account is configured and able to publish packages
- `package.json` uses "files" whitelist to publish only `dist/`, `README.md`, `LICENSE`
- optional `.npmignore` added as a belt-and-suspenders safety measure
- `npm pack` output does not include `.mdkg/` or any index files
- `mdkg` binary is installable and runs (`mdkg --help`)

# Files Affected

- package.json
- README.md
- LICENSE
- .npmignore (optional)
- .gitignore

# Implementation Notes

- Prefer "files" whitelist over ignore blacklists.
- Ensure `bin` points to `dist/cli.js` (compiled JS) and file has a node shebang.
- Confirm `engines.node >=18`.

# Test Plan

- run `npm pack` and inspect tarball contents
- install locally from tarball to verify bin works

# Links / Artifacts

- rule-4 (repo safety)
- rule-5 (release and versioning)

---

## root:epic-1
qid: root:epic-1
type: epic
title: v1 bootstrap and npm publish
status: progress
priority: 1
path: .mdkg/work/epic-1-v1-bootstrap-and-npm-publish.md
links: npm:mdkg
artifacts: []
refs: rule-1, rule-2, rule-3, rule-4, rule-5, rule-6


# Goal

Ship mdkg v1 as a usable CLI (Node 18+, TypeScript, zero runtime deps) with:

- root-only operation
- registered workspaces
- global indexing + search
- deterministic context packs
- validation + formatting
- next (chain + priority)
- checkpoints
- published to npm

# Scope

Included:

- repo scaffolding (package.json, tsconfig, src layout)
- `.mdkg` rules/design docs/templates/work items (dogfooding)
- CLI commands for v1
- npm publish safety (files whitelist)
- minimal smoke tests / scripts

Excluded (explicitly deferred):

- sqlite/postgres indexing (life git layer)
- per-workspace template overrides
- UI application
- external integrations (MCP server, etc.)

# Milestones

- M1: repo + build pipeline + CLI skeleton
- M2: config + workspace registry + strict frontmatter parser
- M3: indexer + global cache + search/list/show
- M4: pack (md/json/toon) + verbose core inclusion
- M5: validate + format
- M6: next (chain + priority)
- M7: checkpoints and pack integration
- M8: publish v1 to npm + create checkpoint

# Risks

- Strict frontmatter means small mistakes can block indexing (mitigated by `mdkg format` and clear errors)
- Zero runtime dependencies increases implementation burden (keep scope tight)
- Pack determinism and ordering must be consistent (centralize ordering logic)

# Links / Artifacts

Core rules:

- rule-1
- rule-2
- rule-3
- rule-4
- rule-5
- rule-6

Design:

- edd-1
- dec-1
- dec-2
- dec-3
- dec-4
- dec-5
- dec-6
- dec-7

Next tasks:

- task-1
- task-2
- task-3

---

## root:edd-1
qid: root:edd-1
type: edd
title: mdkg cli and index architecture (v1)
path: .mdkg/design/edd-1-mdkg-cli-and-index-architecture.md
links: []
artifacts: []


# mdkg CLI and index architecture (v1)

## Overview

mdkg is a **TypeScript** CLI targeting **Node 18+** with **zero runtime dependencies**.

It manages a local Markdown knowledge graph stored across:
- the root workspace: `./.mdkg/`
- registered subdirectory workspaces: `<workspace>/.mdkg/` (docs live near code)

The CLI operates at repo root using:
- `.mdkg/config.json` as canonical configuration
- `.mdkg/index/global.json` as the authoritative cached index

Key goals:
- deterministic behavior
- fast search and traversal
- strict frontmatter parsing
- powerful context pack generation

## Root-only flow

All commands assume they are invoked from the repo root unless `--root` is provided.

Root validity check:
- `./.mdkg/config.json` must exist
- if missing: error with instructions (or suggest `mdkg init`)

## Configuration

Config lives at:
- `./.mdkg/config.json`

It includes:
- `schema_version`
- workspace registry
- index settings (auto reindex, tolerant mode)
- pack defaults and limits
- global templates location and default set
- work enums (status, priority bounds)

Config loading:
- strict validation of required keys
- schema migrations supported via version upgrade functions

## Workspace registry

Workspaces are explicit in config:
- alias → `{ path, enabled, mdkg_dir }`

Rules:
- aliases are lowercase and unique
- paths are relative to repo root
- `mdkg_dir` defaults to `.mdkg`

Docs live near code:
- workspace docs are in `<workspace_path>/.mdkg/...`

No runtime discovery:
- only configured workspaces are indexed and searched
- indexing scans registered workspace doc roots

## Indexing

### Source locations

Index inputs include:
- root `.mdkg/core|design|work` markdown files
- each workspace’s `.mdkg/core|design|work` markdown files

Templates are **not indexed** as nodes.

### Frontmatter parsing

Frontmatter uses a restricted subset (see rule-1 and rule-6). Parsing must be strict.

On invalid frontmatter:
- default indexing fails (exit code 2 or 4 depending on implementation)
- optional tolerant mode skips invalid nodes and continues with warnings

### Node model

Each markdown file becomes a node:
- `id`, `type`, `title`, `created`, `updated`
- optional searchable metadata: `tags`, `owners`, `links`, `artifacts`, `refs`, `aliases`
- work metadata: `status`, `priority`
- graph edges: `epic`, `parent`, `relates`, `blocked_by`, `blocks`, `prev`, `next`
- note: `refs` is a searchable reference list but is NOT traversed by default pack traversal
- note: `links` and `artifacts` store any searchable reference strings (may include URLs)

### Global uniqueness and qualified IDs

In the global index, every node has:
- `qid = <ws_alias>:<id>`
- `ws = <ws_alias>`
- `path = relative path to markdown file`

Edges are normalized to qualified IDs internally:
- local edge references without `ws:` are assumed to be in the same workspace as the node
- qualified edges (`ws:id`) resolve across workspaces

Ambiguity handling:
- if a qualified reference cannot be resolved: validation error
- if a user queries an unqualified ID that exists in multiple workspaces: CLI errors and suggests qualified IDs

### Index output format (global.json)

Root index output path:
- `./.mdkg/index/global.json`

Recommended structure:

- `meta`:
  - tool version
  - schema_version
  - generated_at
  - root path
  - included workspaces
- `workspaces`:
  - alias → `{ path, enabled }`
- `nodes`:
  - `qid` → node record:
    - `id`, `qid`, `ws`, `type`, `title`, `status`, `priority`, `created`, `updated`, `tags`, `owners`, `links`, `artifacts`, `refs`, `aliases`, `path`
    - `edges` (qualified)
- `reverse_edges`:
  - precomputed reverse adjacency by edge type for fast queries:
    - children of epic
    - blocked graph
    - prev/next chain linkers
- `aliases` (optional):
  - numeric ID counters or convenience lookups

## Staleness and auto reindex

Default behavior:
- commands requiring graph data check if `global.json` is stale:
  - global missing → stale
  - config mtime newer than global → stale
  - any `*.md` in registered `.mdkg/` docs folders newer than global → stale

If stale:
- auto rebuild index unless `--no-reindex` or config disables auto reindex

v1 keeps this simple using file mtimes. A file manifest may be introduced later if performance demands it.

## Commands architecture

Implementation approach:
- `src/cli.ts` routes to `src/commands/*.ts`
- shared logic in `src/core`, `src/graph`, `src/templates`, `src/pack`

Each command should:
1) enforce root (or resolve `--root`)
2) load config (migrate if needed)
3) ensure index ready (auto reindex if stale)
4) perform action
5) output deterministically
6) exit with stable code per rule-3

## Packs architecture

Pack generation uses:
- global index nodes/edges
- BFS traversal with configurable depth and edge selection
- deterministic ordering (rule-2)
- `--verbose` includes pinned core docs from `.mdkg/core/core.md`
- pack node headers must surface key searchable fields (at minimum: `links` and `artifacts`, plus `refs` when present)

Exports:
- Markdown (human/agent)
- JSON (programmatic agent)
- TOON (agent / structured)

Packs must enforce limits and record truncation metadata.

## Validation

Validation checks:
- strict frontmatter parsing
- required fields present by type (rule-6)
- status/priority enums valid
- edges resolve to existing nodes
- cycles in `prev/next` chains (warn or error; v1 recommend error for cycles)
- duplicate IDs in a workspace (error)
- ambiguous unqualified IDs for user queries (CLI error, not index error)

## Formatting

Formatting is conservative:
- normalizes frontmatter output format (key order, list formatting)
- enforces lowercase for keys and enums
- leaves body content unchanged where possible
- may normalize newline endings

## Security and publish safety

- `.mdkg/index/` is generated and must be gitignored
- npm package publishes only `dist/`, `README.md`, `LICENSE` via `files` whitelist
- `.mdkg/` docs never published in npm package

---

## root:dec-1
qid: root:dec-1
type: dec
title: config schema versioning and migrations
status: accepted
path: .mdkg/design/dec-1-config-schema-and-migrations.md
links: []
artifacts: []


# Context

mdkg stores repo-wide settings in `.mdkg/config.json`. This file is “data” that must remain usable across versions of the CLI.

Without versioning, early changes would break existing repos and make upgrades painful.

# Decision

- `.mdkg/config.json` includes a required integer: `schema_version`
- mdkg includes deterministic migration functions to upgrade older schemas to the latest schema
- migration strategy is “stepwise”:
  - N → N+1 transforms only
  - repeat until latest
- migrations must be safe and transparent:
  - trivial renames may auto-migrate on load
  - behavior-changing migrations may require explicit `mdkg config migrate` in the future

# Alternatives considered

- No versioning (reject): breaks existing repos quickly
- “Loose” versioning without migrations (reject): pushes work to users and creates drift
- External migration frameworks (reject): violates zero runtime dependencies

# Consequences

- The CLI must maintain migration code for older versions
- Config shape becomes a stable contract and supports future tools (including life git ingestion)

---

## root:dec-2
qid: root:dec-2
type: dec
title: root-only operation and registered workspaces (no discovery)
status: accepted
path: .mdkg/design/dec-2-root-only-and-registered-workspaces.md
links: []
artifacts: []


# Context

We want deterministic behavior and fast operation. Runtime “workspace discovery” adds complexity and uncertainty.

We also want support for multiple workspaces (subdirectories) with docs near code, indexed globally.

# Decision

- mdkg is run at the repo root by default (or via `--root`)
- `.mdkg/config.json` defines a workspace registry
- only registered workspaces are indexed and searched
- workspaces store docs near code at `<workspace>/.mdkg/...`
- the root index contains the authoritative global index across workspaces

# Alternatives considered

- Walk up directories from cwd to find nearest workspace (reject): nondeterministic for global operations
- Implicit discovery of workspaces by scanning for `.mdkg` folders (reject): surprises users and slows commands

# Consequences

- Users must add workspaces explicitly via config/CLI
- Indexing is predictable and bounded to known directories
- All commands can default to global behavior with easy filtering

---

## root:dec-3
qid: root:dec-3
type: dec
title: cache is default and commands auto reindex when stale
status: accepted
path: .mdkg/design/dec-3-cache-default-and-auto-reindex.md
links: []
artifacts: []


# Context

Graph search and traversal should be fast even as documentation grows. A cache/index is required for good UX.

We also want low friction for humans and agents; stale caches should not cause confusing behavior.

# Decision

- caching is enabled by default
- authoritative global cache path: `.mdkg/index/global.json`
- commands that require graph data automatically rebuild the index when stale
- a manual command exists: `mdkg index`
- strict indexing is default; tolerant mode is an escape hatch

# Alternatives considered

- no cache (reject): slow scanning and parsing on every command
- cache optional default-off (reject): encourages slow, inconsistent usage
- require manual index always (reject): too easy to forget, poor agent UX

# Consequences

- index rebuild must be reliable and deterministic
- staleness detection must be correct (config and markdown mtimes)
- index path must remain gitignored and safe

---

## root:dec-4
qid: root:dec-4
type: dec
title: strict frontmatter and flexible body structure
status: accepted
path: .mdkg/design/dec-4-frontmatter-strict-body-flexible.md
links: []
artifacts: []


# Context

The knowledge graph and search depend on parsing frontmatter reliably. LLM agents may sometimes create malformed structures in document bodies.

We need strictness where it matters and flexibility where it does not.

# Decision

- frontmatter must follow the restricted subset and is strictly validated
- invalid frontmatter breaks indexing by default
- document body structure is guided by templates but not strictly enforced
- validator warns on missing recommended headings but does not break indexing

# Alternatives considered

- enforce full markdown schema with strict headings (reject): too brittle for humans/agents
- allow “best effort” frontmatter parsing (reject): leads to silent corruption of graph

# Consequences

- `mdkg validate` must clearly report frontmatter violations
- `mdkg format` should help repair common frontmatter formatting issues
- templates become important for agent usability

---

## root:dec-5
qid: root:dec-5
type: dec
title: global templates only (root templates)
status: accepted
path: .mdkg/design/dec-5-global-templates-only.md
links: []
artifacts: []


# Context

Per-workspace template overrides add complexity. v1 should remain simple and consistent.

We still want strong templating to support agent workflows.

# Decision

- templates are global only and live at `.mdkg/templates/<set>/<type>.md`
- workspace template overrides are disabled in v1
- template sets are supported (default/minimal/verbose)
- templates are filled via token substitution only (no template engine dependencies)

# Alternatives considered

- workspace overrides (defer): revisit when v1 is stable
- external template engines (reject): violates zero dependency constraint

# Consequences

- consistent document structure across the repo
- easier implementation and validation
- specialization happens via fields/tags/workspace separation, not templates

---

## root:dec-6
qid: root:dec-6
type: dec
title: next priority uses chain first then priority (p0..p9)
status: accepted
path: .mdkg/design/dec-6-next-mechanisms-chain-and-priority.md
links: []
artifacts: []


# Context

We need an easy “what should I do next?” capability.

Two complementary patterns exist:
- explicit curated flow (`prev/next`)
- triage and ordering (`priority`)

# Decision

- mdkg supports both:
  - explicit `prev/next` chains for linear progress
  - `priority: 0..9` for global ordering and triage
- `mdkg next` uses:
  1) chain (`next:`) when present and unambiguous
  2) otherwise priority-based selection among active statuses

Priority meaning:
- `0` = breaking/urgent
- `9` = later

# Alternatives considered

- chain only (reject): not enough for non-linear backlogs
- priority only (reject): lacks explicit linear planning when needed

# Consequences

- index must support fast filtering by status and priority
- CLI must resolve ambiguity and provide clear suggestions

---

## root:dec-7
qid: root:dec-7
type: dec
title: checkpoints (chk) are first-class compression nodes
status: accepted
path: .mdkg/design/dec-7-checkpoints-as-compression-nodes.md
links: []
artifacts: []


# Context

Long-running projects accumulate many nodes. Packs can become too large and time-consuming for humans and agents.

We need a way to summarize completed phases while retaining references and verification details.

# Decision

- add `chk-*` nodes as first-class checkpoint records
- checkpoints summarize a set of work and can serve as context anchors
- checkpoints are allowed per workspace
- checkpoint templates include structured sections for summary, scope, verification, and links
- checkpoints should link to the epic and key docs via edges
- checkpoints may include a `scope: [id, ...]` frontmatter list when practical

# Alternatives considered

- rely on linking many done tasks (reject): packs become noisy and slow to read
- external summaries in README/wiki (reject): not graph-connected or pack-aware

# Consequences

- agents can consume checkpoint summaries instead of many individual nodes
- packs can prefer checkpoints (optional future flag) to reduce size
- project continuity improves significantly

---

## root:rule-1
qid: root:rule-1
type: rule
title: mdkg conventions (naming, ids, frontmatter, status, priority, templates)
path: .mdkg/core/rule-1-mdkg-conventions.md
links: []
artifacts: []


# mdkg conventions

This rule defines the file-first conventions for a local Markdown knowledge graph managed by **mdkg**.

## Principles

- Markdown files are the source of truth.
- Identity is the `id` in frontmatter, not the path or filename.
- Graph edges are explicit in frontmatter and reference IDs.
- Anything that must be searchable (external URLs, refs, artifacts) should be stored in frontmatter.
- Document bodies are for narrative detail; frontmatter is for indexing and graph structure.
- Everything is lowercase on disk (IDs, types, filenames, enums).
- The CLI may accept any case but MUST normalize to lowercase before processing.
- Frontmatter must be strict and valid (or the graph breaks).
- Body structure is template-guided and flexible (warnings, not hard failures).
- Templates are global (root-only) in v1.

## Root-only operation

mdkg commands are intended to run at the repo root.

- Root is defined by `./.mdkg/config.json`.
- No directory-walking “workspace discovery” at runtime.
- Workspaces are explicitly registered in `.mdkg/config.json`.

## Workspaces

A workspace is a registered project area (usually a subdirectory). Workspace docs live near code:

- `<workspace>/.mdkg/`

Workspaces are indexed by the root indexer according to `.mdkg/config.json`.

Qualified IDs exist for global uniqueness in the index:

- `qid = <workspace_alias>:<id>`
- example: `root:task-1`, `e2e:bug-3`

Local IDs remain unqualified in files.

## File naming

Canonical filename format:

`<prefix>-<number>-<slug>.md`

Rules:
- `<prefix>` MUST be lowercase.
- `<number>` MUST be an integer with no zero padding.
- `<slug>` SHOULD be lowercase kebab-case.
- Renames are allowed; identity remains stable via frontmatter `id`.

## Node types and prefixes

Design + core:
- `rule-*` — rules and conventions
- `prd-*` — product requirements document
- `edd-*` — engineering design document
- `dec-*` — decision record (generic, not only architecture)
- `prop-*` — proposal (early-stage)

Work:
- `epic-*`
- `feat-*` (optional)
- `task-*`
- `bug-*`
- `chk-*` — checkpoint (phase summary / compression node)

## IDs

Canonical ID format:

`<prefix>-<number>`

Examples:
- `task-183`
- `edd-14`
- `dec-3`
- `chk-1`

IDs MUST be lowercase and unique within a workspace. Global uniqueness is achieved via qualified IDs in the global index.

## Status

Work items store status in frontmatter only (no status directories).

Work status enum:
- `backlog`
- `blocked`
- `todo`
- `progress`
- `review`
- `done`

## Priority

Work items MAY include:

- `priority: 0..9`

Meaning:
- `0` = breaking / urgent (must be addressed immediately)
- `9` = later / lowest urgency

Priority is used as a default ranking when no explicit `prev/next` chain is present.

## Frontmatter (restricted subset)

Frontmatter MUST be the first lines of the file:

- begins with `---`
- ends with the next `---`

Allowed forms per line:

`key: value`

Keys:
- lowercase snake_case: `[a-z][a-z0-9_]*`

Values:
- string (rest of line)
- boolean: `true` / `false`
- list: `[a, b, c]` (comma-separated; items trimmed)
- empty lists SHOULD be written as `[]` for list fields

Disallowed:
- nested maps
- multiline values
- duplicate keys

## Required fields

All nodes MUST include:
- `id`
- `type`
- `title`
- `created` (YYYY-MM-DD)
- `updated` (YYYY-MM-DD)

Work items (`epic/feat/task/bug/chk`) MUST include:
- `status`

Work items MAY include:
- `priority`

Optional searchable metadata

All nodes MAY include:
- `tags: [a, b, c]`
- `owners: [a, b, c]`
- `links: [ref, ref]` (any searchable reference string; may include URLs)
- `artifacts: [ref, ref]` (build outputs, releases, commits, PRs, tarballs, etc.)
- `refs: [id, id]` (non-edge references to other nodes)
- `aliases: [text, text]` (extra searchable terms)

`dec-*` MUST include:
- `status: proposed|accepted|rejected|superseded`

## Graph edges

Edges reference IDs (or qualified IDs when cross-workspace).

Supported edge keys:
- `epic: epic-#`
- `parent: feat-#`
- `relates: [id, id]`
- `refs: [id, id]` (non-edge references; searchable but not traversed by default)
- `blocked_by: [id, id]`
- `blocks: [id, id]`
- `prev: id`
- `next: id`

Notes:
- Reverse relationships (e.g., “children of epic”) are derived by indexing.
- `prev/next` SHOULD be used for explicit “immediate next” flows.
- Priority SHOULD be used for triage when chain is absent or incomplete.

## Templates

Templates are global in v1 and live at:

- `.mdkg/templates/<set>/<type>.md`

Template sets (recommended):
- `default`
- `minimal`
- `verbose`

Templates are filled by token substitution (no template engine dependency). Optional scalar fields (like `epic`, `parent`, `prev`, `next`) should be omitted when empty; list fields should default to `[]`.

Body headings are guidance only. Frontmatter is strictly validated.

## Checkpoints

Checkpoints (`chk-*`) are first-class nodes used to summarize completed phases and compress context.

They SHOULD include:
- a summary of outcomes
- verification/testing notes
- key decisions referenced
- searchable links and artifacts in frontmatter (see `links` and `artifacts`)
- a `scope` list in frontmatter when possible (IDs covered)

## Index and cache

The cache is enabled by default.

- Root global index lives at `.mdkg/index/global.json`
- Index is rebuilt automatically when stale unless disabled by flag/config.
- `.mdkg/index/` is generated and MUST be gitignored.

## Safety guidance (high level)

mdkg content may include sensitive notes. Ensure production artifacts don’t include `.mdkg/`:
- prefer publishing only `dist/` via package.json `files`
- consider `.npmignore` / `.dockerignore` excludes

---

## root:rule-2
qid: root:rule-2
type: rule
title: mdkg context pack rules (selection, ordering, verbose, checkpoints)
path: .mdkg/core/rule-2-context-pack-rules.md
links: []
artifacts: []


# mdkg context pack rules

A **context pack** is a deterministic export that bundles the root node plus relevant linked nodes, ordered for agent execution and constraint compliance.

Packs are the core feature that turns a Markdown graph into a repeatable “what to read before you code” artifact.

## Goals

- Deterministic: same repo state + same command → same pack ordering and contents.
- Relevant: include the minimum set needed to execute the work well.
- Safe: enforce limits to prevent runaway packs.
- Flexible: export to Markdown / JSON / TOON / XML.

## Command (conceptual)

`mdkg pack <id-or-qid> [--depth N] [--verbose] [--edges ...] [--ws <alias>] [--format md|json|toon|xml] [--out <path>]`

Notes:
- CLI normalizes to lowercase before processing.
- Packs are generated using the global index (auto-reindexed if stale).

## Node selection

### Root node
The root node is always included.

### Default depth
Default traversal depth is `2` unless overridden.

### Default edges
By default, traversal includes:
- `parent`
- `epic`
- `relates`

Non-edge references and metadata fields like `refs`, `links`, and `artifacts` are searchable and included in pack exports, but they are NOT traversed by default unless their corresponding graph edge keys are selected.

Optional edges (include only when requested via `--edges`):
- `blocked_by`
- `blocks`
- `prev`
- `next`

`--edges` adds to the default edge set; duplicates are ignored.

### Traversal method
- BFS traversal from the root to the specified depth.
- Nodes are de-duplicated by `qid` (qualified ID) in global mode.

## Ordering rules

Ordering is designed to maximize agent usefulness and rule compliance.

### Task-root ordering (recommended default)

1) Root `task-*` / `bug-*`
2) Immediate context:
   - `parent` (if present)
   - `epic` (if present)
   - related `chk-*` (checkpoint summaries) when present
   - blockers/blocked-by nodes when they are immediate (depth=1) and included via `--edges`
3) Architecture and constraints:
   - `edd-*`
   - `dec-*`
   - `rule-*`
4) Product requirements:
   - `prd-*`
5) Supporting docs:
   - `prop-*` (and any future supporting types)
6) Work graph neighbors (if included):
   - blockers, blocks, prev/next chain, related tasks/bugs

### Non-task root ordering (fallback)

If the root is not a `task-*` or `bug-*`, the root is still first. Remaining nodes are ordered by type priority:

1) `edd-*`
2) `dec-*`
3) `rule-*`
4) `prd-*`
5) `prop-*`
6) `epic-*`
7) `feat-*`
8) `task-*`
9) `bug-*`
10) `chk-*`

### Tie-breakers (stable determinism)

Within each group:
1) type priority (as listed above)
2) numeric ID ascending (use the trailing number in `<prefix>-<number>` when present; otherwise treat as infinity)
3) title lexicographic (final tie-break)

## Verbose mode (`--verbose`)

Verbose mode is intended for “fresh agent sessions” and MUST add baseline rules even if not directly linked.

When `--verbose` is enabled:
- include IDs listed in `.mdkg/core/core.md` (one per line)
- pinned core inclusion MUST obey pack limits
- IDs are resolved as `id` or `qid`; ambiguous matches should warn and be skipped unless a qualified ID is provided

If a pinned core ID does not exist, pack generation should warn but continue.

## Checkpoints (compression nodes)

Checkpoints (`chk-*`) are phase summaries that reduce context sprawl.

### Recommended checkpoint frontmatter fields
- `scope: [id, id, ...]` (IDs covered by the checkpoint)

### Pack behavior with checkpoints
- If the root node relates to a checkpoint, include the checkpoint early (immediate context).
- Optional future behavior (not required for v1): `--prefer-checkpoints`
  - when enabled, if many “done” nodes are in scope and a checkpoint covers them, include the checkpoint instead of the underlying nodes (while still including core constraints like rules/decisions as needed).

## Limits

Default limits (configurable):
- `max_nodes: 25`
- `max_bytes: 2,000,000` for Markdown output

When a limit is hit:
- the root node MUST remain included
- higher-priority types (`edd/dec/rule/prd`) should be favored over low-priority neighbors
- pack metadata must record that truncation occurred
- `max_bytes` is enforced for Markdown output; other formats ignore byte limits in v1

## Export formats

### Markdown (`--format md`)
Markdown packs MUST include:
- a pack header with metadata (root, depth, verbose, node count, truncation flags)
- an ordered “included nodes” list
- each node content separated by a stable divider
- node headers should include: `qid`, `type`, `title`, `status` (if any), `priority` (if any), `path`, and the searchable frontmatter lists `links` and `artifacts`

Node bodies should exclude the full raw frontmatter by default to reduce noise, but the header MUST surface key searchable fields (at minimum: `links` and `artifacts`, plus `refs` when present). A future flag like `--include-frontmatter` may include the full raw frontmatter.

### JSON (`--format json`)
JSON packs MUST include:
- `meta` (root, generation timestamp, depth, verbose, truncation info)
- `nodes` array in the same order as Markdown packs
- each node includes:
  - `qid`, `id`, `workspace`, `type`, `title`, `status`, `priority` (if any), `path`
  - `frontmatter` (parsed restricted subset, including `links`, `artifacts`, `refs`, and `aliases` when present)
  - `body` (content excluding frontmatter)

### TOON (`--format toon`)
TOON packs SHOULD mirror JSON semantics:
- meta
- ordered nodes
- node fields as above

Exact TOON encoding is defined by the project’s TOON spec adoption.

### XML (`--format xml`)
XML packs SHOULD mirror JSON semantics:
- `<pack>` root element with `<meta>` and `<nodes>`
- `<nodes>` contains ordered `<node>` elements
- node fields align with JSON exporter
- list fields are represented as repeated child elements
- body content must be safely encoded

## Determinism requirements

Given the same repo state and command flags:
- included node set must be identical
- ordering must be identical
- only timestamps in metadata may differ between runs

---

## root:rule-3
qid: root:rule-3
type: rule
title: mdkg cli contract (root-only, commands, flags, exit codes)
path: .mdkg/core/rule-3-cli-contract.md
links: []
artifacts: []


# mdkg CLI contract

This rule defines the **stable CLI behavior** for mdkg v1. The CLI is designed for humans and AI coding agents to use deterministically.

## Root-only requirement

mdkg commands are intended to run at the **repo root**.

- The repo root is the current working directory containing `./.mdkg/config.json`.
- mdkg MUST NOT walk upward to find config by default.
- If config is not found in the current directory:
  - mdkg MUST exit non-zero and print a helpful error.
  - Users may pass `--root <path>` to run from elsewhere.

### `--root`
`--root <path>` sets the root directory explicitly.

- `<path>` may be the repo root or a path that contains `.mdkg/config.json`.
- When `--root` is set, mdkg behaves as if it was invoked from that root.

## Case normalization

- The CLI MUST accept any case for user inputs (types, IDs, flags values).
- Before processing, mdkg MUST normalize:
  - IDs to lowercase
  - types to lowercase
  - status to lowercase
  - workspace aliases to lowercase
  - template set names to lowercase

## Cache / auto reindex (default)

- Cache is enabled by default.
- Commands that rely on the graph MUST:
  1) load `.mdkg/config.json`
  2) check if the global index is stale
  3) auto-reindex if stale (unless `--no-reindex` or config disables)
  4) proceed using the global index

### Flags
- `--no-cache` (optional): bypass reading the cache (debug only)
- `--no-reindex` (optional): do not auto rebuild when stale (CI/debug)

In v1, `--no-cache` and `--no-reindex` are intended as escape hatches, not the normal workflow.

## Workspace behavior

Workspaces are registered in `.mdkg/config.json`.

- Default behavior is **global** across all registered workspaces.
- Many commands SHOULD support:
  - `--ws <alias>` to filter results to a workspace
  - `--ws all` to force global behavior (optional; may be default)

Qualified IDs may be used as input:
- `<ws>:<id>` (example: `e2e:task-12`)

If a user provides an unqualified ID and it is ambiguous globally:
- mdkg MUST error and suggest qualified IDs.

## Exit codes (v1)

- `0` success
- `1` general error / invalid usage
- `2` validation error (frontmatter/schema/graph integrity)
- `3` not found (node/workspace/template not found)
- `4` index error (index build failure)

## Output conventions

- Human-readable output to stdout.
- Errors to stderr.
- Commands should be script-friendly:
  - concise outputs for single items
  - predictable formatting
  - optional `--json` output later (not required for v1)
  - when printing node summaries (e.g., `show`/list results), outputs SHOULD surface key searchable frontmatter fields such as `links` and `artifacts`

## Command set (v1 target)

### Initialization
- `mdkg init`
  - creates `.mdkg/` directory structure at root
  - creates `.mdkg/config.json` if missing
  - creates core docs and templates if missing
  - does NOT overwrite existing docs unless `--force`

### Workspace management (registered, no discovery)
- `mdkg workspace ls`
- `mdkg workspace add <alias> <path>`
- `mdkg workspace rm <alias>`

### Indexing
- `mdkg index`
  - rebuild global cache `.mdkg/index/global.json`
  - strict by default (fails on invalid frontmatter)
  - optional `--tolerant` to skip invalid nodes (escape hatch)

### Create nodes
- `mdkg new <type> "<title>" [flags]`
  - uses global templates (root-only) via token substitution
  - writes into the appropriate workspace-local `.mdkg/<area>/` folder
  - updates index if necessary

Common flags:
- `--ws <alias>` (default `root`)
- `--status <status>` (work items)
- `--priority <0..9>` (work items)
- `--epic <id>`
- `--parent <id>`
- `--relates <id,id,...>`
- `--blocked-by <id,id,...>`
- `--blocks <id,id,...>`
- `--prev <id>`
- `--next <id>`
- `--links <ref,ref,...>`
- `--artifacts <ref,ref,...>`
- `--refs <id,id,...>`
- `--aliases <text,text,...>`
- `--template <set>` (default from config)

### Read/search
- `mdkg show <id-or-qid>`
- `mdkg search "<query>" [--type <type>] [--status <status>] [--ws <alias>]`
  - search SHOULD match on IDs, titles, tags, path tokens, and searchable frontmatter lists (`links`, `artifacts`, `refs`, `aliases`)
- `mdkg list [--type <type>] [--status <status>] [--ws <alias>] [--epic <id>] [--blocked] [--priority <n>]`

### Graph views
- `mdkg tree <epic-id-or-qid> [--ws <alias>]`
- `mdkg neighbors <id-or-qid> --depth <n> [--edges <...>]`

### Packs (core feature)
- `mdkg pack <id-or-qid> [--depth <n>] [--verbose] [--edges <keys>] [--format md|json|toon|xml] [--out <path>] [--ws <alias>]`
  - `--edges` adds to the default edge set
  - `--out` writes to a file (create parent dirs; overwrite if exists)
  - if `--out` is omitted, write to `.mdkg/pack/pack_<kind>_<id>_<timestamp>.<ext>`
  - short flags supported: `-o`, `-f`, `-v`, `-d`, `-e`, `-w`, `-r`

### Next priority
- `mdkg next [<id-or-qid>] [--ws <alias>]`
  - If `<id>` provided: follow `next` if present; otherwise fall back to priority-based selection.
  - If no `<id>` provided: use priority-based selection (and optionally an epic filter in future).

### Checkpoints
- `mdkg checkpoint new "<title>" [--ws <alias>] [--relates <id,...>] [--scope <id,...>]`
  - creates a `chk-*` node from template
  - designed as a phase summary / compression node

### Validation and formatting
- `mdkg validate`
  - strict frontmatter + graph integrity checks (exit code 2 on failure)
- `mdkg format`
  - normalize frontmatter formatting and casing
  - avoid destructive body edits

---

## root:rule-4
qid: root:rule-4
type: rule
title: mdkg repo safety (ignore rules, publish safety, deployment safety)
path: .mdkg/core/rule-4-repo-safety-and-ignores.md
links: []
artifacts: []


# Repo safety and ignores

mdkg content may contain sensitive notes and internal project planning. This rule defines how to prevent `.mdkg/` content from leaking into build artifacts, containers, and npm packages.

## Safety goals

- `.mdkg/` must not be shipped to production deployments.
- `.mdkg/` must not be published to npm.
- `.mdkg/index/` must never be committed.

## Git ignore requirements

The repo MUST ignore at minimum:

- `node_modules/`
- `dist/`
- `.mdkg/index/`

Recommended `.gitignore` entries:
- `.mdkg/index/`
- `.mdkg/index/**`

## npm publish safety (required)

The npm package MUST publish only the compiled CLI output and essential docs.

Required approach:
- Use `package.json` `"files"` whitelist to ship only:
  - `dist/`
  - `README.md`
  - `LICENSE`

This approach is preferred over blacklists.

Additional belt-and-suspenders:
- Add `.npmignore` that excludes `.mdkg/` and other repo internals, even if `"files"` exists.

## Container and deployment safety (recommended)

If the repo is containerized:
- `.dockerignore` SHOULD exclude:
  - `.mdkg/`
  - `.mdkg/index/`
  - `node_modules/`
  - `dist/` (if built in container)
  - any other local artifacts

For application builds:
- Build tooling SHOULD exclude `.mdkg/` (e.g., tsconfig excludes, bundlers exclude dot-folders).

## mdkg init behavior

`mdkg init` MAY offer optional flags to append ignore entries:

- `--update-gitignore`
- `--update-npmignore`
- `--update-dockerignore`

In v1, mdkg should default to **not** editing user files without an explicit flag.

## Index safety

- `.mdkg/index/` is generated.
- Index files may contain extracted metadata and could expose sensitive strings.
- Index files MUST be ignored from git.
- Index rebuild should be deterministic and safe to regenerate at any time.

## Workspace safety

Workspace-local `.mdkg/` directories (near code) should follow the same rules:
- the content is source-of-truth docs (tracked)
- the workspace-local index folder (if present) should be ignored
- templates remain global (root) in v1

## Summary checklist

- ✅ `.mdkg/index/` ignored
- ✅ npm publishes only `dist/`, `README.md`, `LICENSE`
- ✅ optional `.npmignore` excludes `.mdkg/`
- ✅ `.dockerignore` excludes `.mdkg/` when applicable

---

## root:rule-5
qid: root:rule-5
type: rule
title: mdkg release and versioning (semver, publish checklist)
path: .mdkg/core/rule-5-release-and-versioning.md
links: []
artifacts: []


# Release and versioning

mdkg follows SemVer for CLI stability and long-term compatibility.

## SemVer policy

- MAJOR: breaking CLI contract changes (flags/outputs removed or changed)
- MINOR: new commands/features that are backwards compatible
- PATCH: bug fixes and internal refactors with no contract changes

Configuration and schema versioning:
- `.mdkg/config.json` contains a `schema_version`.
- mdkg MUST support migrating older schemas to the current schema in a deterministic way.
- Backwards compatibility matters more for config and docs than for internal index formats.

## Release artifacts

The npm package MUST include:
- `dist/` compiled output
- `README.md`
- `LICENSE`

It MUST NOT include:
- `.mdkg/` docs
- `.mdkg/index/`
- source code (optional; can be included later, but not required)

## Release checklist (v1)

1) Ensure clean working tree
- no uncommitted changes
- all `.mdkg/index/` ignored

2) Rebuild and validate
- run `mdkg index`
- run `mdkg validate`
- run a pack smoke test (example):
  - `mdkg pack task-1 --verbose --out /tmp/mdkg-pack.md`

3) Update version
- bump `package.json` version (semver)

4) Update changelog (recommended)
- add a short entry describing changes

5) Build
- run `npm run build` (or equivalent)
- confirm `dist/cli.js` exists and is executable as a node script

6) Confirm publish whitelist
- verify `package.json` `"files"` includes only expected files
- optionally run `npm pack` and inspect tarball contents

7) Publish
- `npm publish`

8) Tag and push
- create git tag matching version (example `v0.1.0`)
- push commits and tags

## Release notes guidance

Release notes should call out:
- new commands / flags
- changes to pack behavior
- changes to config schema (and how migration behaves)
- new node types or template changes

---

## root:rule-6
qid: root:rule-6
type: rule
title: mdkg templates and schemas (global templates, required frontmatter, body guidance)
path: .mdkg/core/rule-6-templates-and-schemas.md
links: []
artifacts: []


# Templates and schemas

This rule defines:
- global template sets
- required frontmatter fields per node type
- recommended body headings for agent-friendly editing
- the token substitution contract used by `mdkg new`

## Global templates (v1)

Templates are global and live at:

- `.mdkg/templates/<set>/<type>.md`

Workspace overrides are disabled in v1.

### Template sets

Recommended sets:
- `default` (balanced)
- `minimal` (lean body headings)
- `verbose` (more guidance, more sections)

All sets should provide the same set of types.

## Token substitution

Templates are filled using simple token replacement.

Required tokens supported by v1:
- `{{id}}`
- `{{type}}`
- `{{title}}`
- `{{created}}`
- `{{updated}}`
- `{{status}}` (work items only)
- `{{priority}}` (work items only)

Optional tokens (nice-to-have, may be empty):
- `{{epic}}`
- `{{parent}}`
- `{{prev}}`
- `{{next}}`
- `{{relates}}` (list)
- `{{blocked_by}}` (list)
- `{{blocks}}` (list)
- `{{tags}}` (list)
- `{{owners}}` (list)
- `{{links}}` (list)
- `{{artifacts}}` (list)
- `{{refs}}` (list)
- `{{aliases}}` (list)

## Frontmatter requirements by type

All nodes:
- `id`
- `type`
- `title`
- `created` (YYYY-MM-DD)
- `updated` (YYYY-MM-DD)

Searchable metadata (optional)

All nodes MAY include the following searchable frontmatter lists:
- `tags: [a, b, c]`
- `owners: [a, b, c]`
- `links: [ref, ref]` (any searchable reference string; may include URLs)
- `artifacts: [ref, ref]` (build outputs, releases, commits, PRs, tarballs, etc.)
- `refs: [id, id]` (non-edge references to other nodes)
- `aliases: [text, text]` (extra searchable terms)

List fields SHOULD be written as `[]` when empty.
Optional scalar graph fields (like `epic`, `parent`, `prev`, `next`) should be omitted when empty.

Work items (`epic/feat/task/bug/chk`):
- `status` (enum)
- optional `priority` (0..9)
- optional graph edges: `epic`, `parent`, `relates`, `blocked_by`, `blocks`, `prev`, `next`

Decision records (`dec-*`):
- `status` (enum: `proposed`, `accepted`, `rejected`, `superseded`)
- optional `supersedes: dec-#`

Design docs (`prd/edd/prop`):
- no required status field
- recommended `tags`

Rules (`rule-*`):
- no required status field

## Body headings (guidance only)

Body headings are strongly recommended for agent usability but should not be hard requirements.

### Task / bug template headings (recommended)

- Overview
- Acceptance Criteria
- Files Affected
- Implementation Notes
- Test Plan
- Links / Artifacts

### Epic template headings (recommended)

- Goal
- Scope
- Milestones
- Out of Scope
- Risks
- Links / Artifacts

### Checkpoint template headings (recommended)

- Summary
- Scope Covered
- Decisions Captured
- Implementation Summary
- Verification / Testing
- Known Issues / Follow-ups
- Links / Artifacts

### PRD headings (recommended)

- Problem
- Goals
- Non-goals
- Requirements
- Acceptance Criteria
- Metrics / Success
- Risks
- Open Questions

### EDD headings (recommended)

- Overview
- Architecture
- Data model
- APIs / interfaces
- Failure modes
- Observability
- Security / privacy
- Testing strategy
- Rollout plan

### Decision record headings (recommended)

- Context
- Decision
- Alternatives considered
- Consequences
- Links / references

## Validation behavior

- Frontmatter: strict, hard fail if invalid.
- Body headings: warn only (do not break indexing).
- If a template is missing:
  - `mdkg new` must fail with a helpful error (exit code 3).

---

## root:rule-guide
qid: root:rule-guide
type: rule
title: agent guide (how to work in this repo using mdkg)
path: .mdkg/core/guide.md
links: []
artifacts: []


# Agent guide

This repo uses **mdkg** to manage documentation, decisions, and work tracking.

## Always start with a pack

Before coding, generate a context pack for the task you’re working on:

- `mdkg pack <task-id> --verbose`

Read:
- the task
- linked design docs (edd/prd)
- decision records (dec)
- rules (rule)

Do not begin implementation without understanding constraints in rules and decisions.

## Keep frontmatter valid and searchable

Frontmatter must remain strictly valid or indexing/search breaks.

- do not introduce multiline values
- do not introduce nested objects
- keep keys lowercase
- keep IDs lowercase
- keep `links: [...]` and `artifacts: [...]` in frontmatter for anything you want searchable
- keep graph fields (`epic`, `parent`, `relates`, `blocked_by`, `blocks`, `prev`, `next`) accurate

## Update the right fields

When you make a meaningful edit:
- update the node’s `updated: YYYY-MM-DD`
- update status and priority as needed

## Work item discipline

- Use `prev/next` to define an explicit “immediate next” chain when the workflow is linear.
- Use `priority: 0..9` for triage and non-linear backlogs.
- Keep `status` accurate.

## Use checkpoints to compress phases

After completing a meaningful phase:
- create a `chk-*` node summarizing work, verification, and links.
- link it to the epic or relevant tasks.
- optionally include a `scope` list of the nodes covered.

Checkpoints reduce context sprawl and improve future packs.

## Validate frequently

After making changes:
- run `mdkg validate`

If formatting drift is common (especially with agent edits):
- run `mdkg format` before committing.

## Indexing behavior

Index is cached by default and auto-reindexed when stale.

If debugging index issues:
- run `mdkg index`
- inspect errors from strict frontmatter enforcement